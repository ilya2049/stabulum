// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
	"net/http"
	product2 "stabulum/internal/app/product"
	queries2 "stabulum/internal/app/queries"
	logger2 "stabulum/internal/common/logger"
	"stabulum/internal/common/testfixture"
	"stabulum/internal/common/testfixture/mocks"
	product4 "stabulum/internal/domain/product"
	mocks2 "stabulum/internal/domain/product/mocks"
	"stabulum/internal/infrastructure/api/router"
	product3 "stabulum/internal/infrastructure/api/router/product"
	"stabulum/internal/infrastructure/config"
	"stabulum/internal/infrastructure/httpserver"
	"stabulum/internal/infrastructure/logger"
	"stabulum/internal/infrastructure/postgres"
	"stabulum/internal/infrastructure/postgres/product"
	"stabulum/internal/infrastructure/postgres/queries"
)

// Injectors from wire.go:

func NewContainer(cfg config.Config) (*Container, func(), error) {
	httpserverConfig := config.NewHTTPServerConfig(cfg)
	usecasesConfig := config.NewUsecasesConfig(cfg)
	loggerLogger := logger.New()
	postgresConfig := config.NewPostgresConfig(cfg)
	db, cleanup, err := postgres.NewConnection(postgresConfig, loggerLogger)
	if err != nil {
		return nil, nil, err
	}
	repository := product.NewRepository(loggerLogger, db)
	usecases := product2.NewUsecases(usecasesConfig, loggerLogger, repository)
	querier := queries.NewQuerier(db, loggerLogger)
	handler := product3.NewHandler(usecases, querier)
	engine := router.New(handler)
	server := httpserver.New(httpserverConfig, engine, loggerLogger)
	container := newContainer(server)
	return container, func() {
		cleanup()
	}, nil
}

func NewTestContainer(cfg config.Config, mockCfg mocks.Config) (*TestContainer, func(), error) {
	usecasesConfig := config.NewUsecasesConfig(cfg)
	spyLogger := testfixture.NewSpyLogger()
	repository := mocks.NewProductRepositoryMock(mockCfg, spyLogger)
	usecases := product2.NewUsecases(usecasesConfig, spyLogger, repository)
	postgresConfig := config.NewPostgresConfig(cfg)
	db, cleanup, err := postgres.NewConnection(postgresConfig, spyLogger)
	if err != nil {
		return nil, nil, err
	}
	querier := queries.NewQuerier(db, spyLogger)
	handler := product3.NewHandler(usecases, querier)
	engine := router.New(handler)
	server := httpserver.NewTestServer(engine)
	testContainer := newTestContainer(server, spyLogger)
	return testContainer, func() {
		cleanup()
	}, nil
}

// wire.go:

var appSet = wire.NewSet(
	apiSet, product2.NewUsecases, config.NewUsecasesConfig,
)

var apiSet = wire.NewSet(wire.Bind(new(http.Handler), new(*gin.Engine)), httpserver.New, router.New, config.NewHTTPServerConfig, product3.NewHandler)

var productionDependenciesSet = wire.NewSet(
	loggerSet,

	newContainer,

	productPostgresStorageSet,
)

var loggerSet = wire.NewSet(wire.Bind(new(logger2.Logger), new(*logger.Logger)), logger.New)

var productPostgresStorageSet = wire.NewSet(postgres.NewConnection, config.NewPostgresConfig, wire.Bind(new(product4.Repository), new(*product.Repository)), product.NewRepository, wire.Bind(new(queries2.ProductQuerier), new(*queries.Querier)), queries.NewQuerier)

var testDependenciesSet = wire.NewSet(
	spyLoggerSet,

	newTestContainer, httpserver.NewTestServer, productMockStorageSet,
)

var spyLoggerSet = wire.NewSet(wire.Bind(new(logger2.Logger), new(*testfixture.SpyLogger)), testfixture.NewSpyLogger)

var productMockStorageSet = wire.NewSet(wire.Bind(new(product4.Repository), new(*mocks2.Repository)), mocks.NewProductRepositoryMock, postgres.NewConnection, config.NewPostgresConfig, wire.Bind(new(queries2.ProductQuerier), new(*queries.Querier)), queries.NewQuerier)
